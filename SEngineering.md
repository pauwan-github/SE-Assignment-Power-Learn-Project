i.	Definition of Software Engineering – is a discipline that deals with the systematic and quantifiable process to the development, operation, and maintenance of software.
ii.	How Software Engineering differs from Traditional Programming?
a.	Scope - Traditional programming emphasizes on coding to solve specific problems, while software engineering contains the whole process of software development.
b.	Process - Software engineering has a structured process i.e. Software Development Life Cycle that includes requirements analysis, design, implementation, testing, deployment, and maintenance while traditional programming might not follow such a structured approach.
c.	Collaboration - Software engineering involves different stakeholders while traditional programming can be made by one person.
d.	Scale and Complexity - Software engineering deals with larger, more complex systems requiring rigorous testing and maintenance, while traditional programming may address smaller, less complex tasks.
Software Development Life Cycle (SDLC) Phases.
1.	Requirement Analysis - Collection and analysis of the software requirements from stakeholders, documentation of functional and non-functional requirements. Eg. Conducting interviews and surveys to understand user needs.
2.	Design - Creating a blueprint for the software architecture, high-level design specifies system architecture, low-level design details the design of individual components. Eg. Creating UML diagrams.
3.	Implementation - Writing the actual code based on the design documents. Eg. Actual coding in languages like Java, Python, etc.
4.	Testing - Confirming that the software works as intended, includes unit testing, integration testing, system testing, and acceptance testing. Eg. Running test cases to ensure functionality and performance.
5.	Deployment - Releasing the software to users. Eg. Launching the product.
6.	Maintenance - Performing updates, bug fixes, and enhancements. Eg. Releasing patches for security vulnerabilities.
iii.	Differences between Agile and Waterfall Models
a.	Characteristics – Agile models are iterative and incremental, flexible and adaptive to changes while waterfall models are sequential and linear.
b.	Process – Agile models development is broken into small sprints or iterations, with regular feedback loops while in waterfall models each phase must be completed before moving on to the next.
c.	Advantages – Agile responds well to changing requirements, improves customer satisfaction through continuous delivery while waterfall models are simple and easy to understand and clear for documentation.
Example of Agile Model - Scrum framework with 2-4 week sprints.
Example of Waterfall Model - Traditional software projects with well-defined requirements
iv.	Key differences between Agile and Waterfall Models.
a.	Flexibility - Agile is more flexible and adaptable, while Waterfall is rigid.
b.	Customer Involvement - Agile involves continuous customer feedback, Waterfall typically does not.
c.	Project Size and Complexity - Agile is preferred for complex, evolving projects, Waterfall suits projects with clear, stable requirements.
v.	Definition of Requirements Engineering – this is the process of defining, documenting, and maintaining the requirements in the engineering design process.
vi.	Requirements Engineering process

a.	Elicitation - Gathering requirements from stakeholders.
b.	Analysis: Understanding and refining the requirements.
c.	Specification: Documenting the requirements in a clear and concise manner.
d.	Validation: Ensuring the requirements accurately represent the stakeholders' needs.
e.	Management: Handling changes to the requirements throughout the project lifecycle.
Importance of Requirements Engineering.
a.	Ensures that the final product meets the needs of users.
b.	Helps to prevent scope creep and reduces project risk.
c.	Provides a clear foundation for design and development.
d.	Designs software principles
vii.	Definition of Modularity – this is the dividing of software systems into separate, independent modules, each responsible for a specific functionality.
viii.	Benefits of Modularity
a.	Easy to maintain - Easier to update and fix individual modules without affecting the entire system.
b.	Scalable - Simplifies scaling by allowing individual modules to be updated or replaced as needed.
c.	Reusable - Modules can be reused across different projects.
Eg: A web application divided into modules for user authentication, database access, and user interface.
ix.	Levels of Testing:

a.	Unit Testing - Testing individual components or functions. Eg. Testing a specific method in a class.
b.	Integration Testing - Testing the interaction between integrated components. Eg. Testing the data flow between the frontend and backend.
c.	System Testing - Testing the complete and integrated software system. Eg. End-to-end testing of an entire web application.
d.	Acceptance Testing - Verifying that the software meets user requirements. Eg. User acceptance testing (UAT) where end-users test the software.
Importance of Testing
a.	Ensures the software works correctly and meets requirements.
b.	Identifies and fixes defects before deployment.
c.	Enhances reliability and performance.
d.	Version Control Systems
x.	Definition of Version Control Systems – These are systems that manage changes to source code over time, enabling multiple developers to collaborate efficiently.

Importance of Version Control Systems
a.	Tracks changes and maintains a history of code.
b.	Facilitates collaboration among developers.
c.	Helps manage and resolve conflicts in code changes.
Eg. Git - Distributed VCS, supports branching and merging, GitHub and GitLab for repository hosting and collaboration, Subversion - Centralized VCS, maintains a single repository.
Example: Apache Subversion for managing project versions.
xi.	Roles of a Software Project Manager:
a.	Planning - Defines project scope, goals, and deliverables.
b.	Scheduling - Create timelines and milestones.
c.	Resource Allocation - Manage resources including team members and budget.
d.	Risk Management - Identify and mitigate project risks.
e.	Communication - Liaise with stakeholders and ensure clear communication.
Challenges in managing software projects
a.	Managing changing requirements and scope creep.
b.	Keeping the project on schedule and within budget.
c.	Ensuring team collaboration and resolving conflicts.
Eg. A project manager overseeing the development of a new mobile application, coordinating between developers, designers, and clients.
xii.	Definition of Software Maintenance – it is the modifying and updating software after its initial deployment to correct faults, improve performance, or adapt to a changed environment.
xiii.	Types of Maintenance:
a.	Corrective: Fixing bugs and errors.
b.	Adaptive: Modifying the software to work in a new or changed environment.
c.	Perfective: Enhancing the software to improve performance or maintainability.
d.	Preventive: Updating the software to prevent future issues.
xiv.	Importance of managing software projects.
a.	Ensures the software remains functional and relevant.
b.	Addresses user-reported issues and enhances user satisfaction.
c.	Extends the lifespan of the software product.
d.	Ethical Considerations in Software Engineering
xv.	Ethical Issues that software engineers face.
a.	Privacy - Ensuring user data is protected.
b.	Security - Developing secure software to prevent breaches.
c.	Intellectual Property - Respecting copyrights and avoiding plagiarism.
d.	Bias and Fairness - Avoiding discriminatory practices in software algorithms.
xvi.	How to Ensure Ethical Standards:
a.	Adhering to professional codes of ethics (e.g., ACM, IEEE).
b.	Conducting regular ethical reviews and audits.
c.	Engaging in continuous education on ethical practices.
d.	Example: Implementing secure coding practices to protect user data from breaches.

